}
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmc ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(((initialState * dtmc) + action) ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
round(as.numeric(((initialState * dtmc)
)
)
)
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, as.numeric(((initialState * dtmc) + action) ^ i), 0))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, (as.numeric(((initialState * dtmc) + action) ^ i))))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
det_model_action <- function(initialState, timesteps, transition_matrix, action) {
#SIMULATION SETUP
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
pipe_df <- rbind(pipe_df, as.list(c(i, dynamic(c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"], pipe_df[i, "d"]),
timesteps, transition_matrix, action))))
}
return(pipe_df)
}
det_model_action(c(42, 55, 23, 15), 5, tm, action_5da)
?lapply()
lapply_pipe <- function(x, f, ...) {
out <- vector("list", length(x))
for (i in seq_along(x)) {
out[[i]] <- f(x[[i]], ...)
}
}
lapply_pipe(1:5, dynamic, initialState, dtmc, action_5da)
lapply_pipe(x = 1:5, f = dynamic, initialState, dtmc, action = action_5da)
dtmc
dtmc[1]
dtmc[1:4]
dtmc@transitionMatrix
lapply_pipe(x = 1:5, f = dynamic, initialState, dtmc@transitionMatrix, action = action_5da)
length(1:5)
x[[1]]
initialState[[1]]
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, (as.numeric(((initialState * dtmc) + action) ^ i))))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
###
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, (as.numeric(((initialState * dtmc)) ^ i))))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, (as.numeric(((initialState * dtmc^i))))))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmcC ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmc ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
pipe_df
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmc ^ i), 2)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
?round()
?apply()
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(c(i, dynamic(c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"], pipe_df[i, "d"]),
timesteps, transition_matrix, action)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
library(markovchain)
library(MDPtoolbox)
library(purrr)
set.seed(1337)
initialState <- c(42, 55, 23, 15)
barplot(initialState, names.arg = letters[1:4], main = "Pipe condition across our estate")
tm <- matrix(c(0.9, 0.1, 0, 0,    #  a
0, 0.8, 0.2, 0,   #  b
0, 0, 0.6, 0.4,         #  c
0, 0, 0, 1),        #  d
nrow = 4, byrow = TRUE) #define the transition matrix
dtmc <- new("markovchain", transitionMatrix = tm,
states = c("a", "b", "c", "d"),
name = "element") #create the DTMC
dtmc
#  For the specific case
action_5da <- c(5, 0, 0, -5)  #  moves 5 pipes from d to a
#  For one year of this policy
(dtmc*initialState) + action_5da
#  Compared to no replacement or no action
(dtmc*initialState) + 0
#  For the general case
dynamic <- function(actual_state, transition_matrix, action) {
next_step_state <- (actual_state * transition_matrix) + action
return(next_step_state)
}
#  For five years in the future
five_years_5da <- dynamic(actual_state = initialState,
transition_matrix = dtmc, action = c(5, 0, 0, -5)) %>%
dynamic(transition_matrix = dtmc, action = c(5, 0, 0, -5)) %>%
dynamic(transition_matrix = dtmc, action = c(5, 0, 0, -5)) %>%
dynamic(transition_matrix = dtmc, action = c(5, 0, 0, -5)) %>%
dynamic(transition_matrix = dtmc, action = c(5, 0, 0, -5))
barplot(five_years_5da, names.arg = letters[1:4], main = "Five year forecast given five pipe replacements per year")
#  is the backlog greater than 50%?
(five_years_5da[[3]] + five_years_5da[[4]]) / sum(five_years_5da)
action <- action_5da
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
#SIMULATION SETUP
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc) + action)
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
pipe_df[nrow(pipe_df) + 1, ]
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc) + action)
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#SIMULATION SETUP
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(c(i, (c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc) + action))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
#SIMULATION SETUP
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(c(i, round(x = c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc, digits = 0) + action))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
initialState <- c(42, 55, 23, 15)
timesteps <- 5
action <- action_5da
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, as.numeric(initialState * dtmc ^ i)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc + action))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(round(x = c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc + action)), digits = 0)
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
det_model_action <- function(initialState, timesteps, transition_matrix, action) {
#SIMULATION SETUP
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
pipe_df[1, ] = c(0, initialState)
print(pipe_df)
for (i in 1:timesteps) {
newrow <- as.list(round(x = c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc + action)), digits = 0)
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
return(pipe_df)
}
det_model_action(initialState, 10, dtmc, action_5da)
det_model_action <- function(initial_state, timesteps, transition_matrix, action) {
#  DATAFRAME SETUP to hold simulated data
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
#  First row of the dataframe
pipe_df[1, ] = c(0, initial_state)
#print(pipe_df)  #  debug
#  ITERATION, dynamic, needs to consider action effects on pipes condition
for (i in 1:timesteps) {
newrow <- as.list(round(x = c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc + action)), digits = 0)
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#  Our v
pipe_df %>%
mutate(backlog_sum = c + d, backlog_prop = (c + d) / (a + b + c + d))
return(pipe_df)
}
det_model_action(initialState, 10, dtmc, action_5da)
library(dplyr)
det_model_action(initialState, 10, dtmc, action_5da)
det_model_action <- function(initial_state, timesteps, transition_matrix, action) {
#  DATAFRAME SETUP to hold simulated data
pipe_df <- data.frame( "timestep" = integer(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
#  First row of the dataframe
pipe_df[1, ] = c(0, initial_state)
#print(pipe_df)  #  debug
#  ITERATION, dynamic, needs to consider action effects on pipes condition
for (i in 1:timesteps) {
newrow <- as.list(round(x = c(i, c(pipe_df[i, "a"], pipe_df[i, "b"],
pipe_df[i, "c"],
pipe_df[i, "d"]) * dtmc + action)), digits = 0)
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#  Our v
pipe_df <- pipe_df %>%
mutate(backlog_sum = c + d, backlog_prop = (c + d) / (a + b + c + d))
return(pipe_df)
}
det_model_action(initialState, 10, dtmc, action_5da)
policy1 <- det_model_action(initialState, 10, dtmc, action_5da)
tail(policy1, 5)
plot(policy1$timestep, policy1$backlog_prop)
?plot()
plot(policy1$timestep, policy1$backlog_prop, type = "l")
plot(policy1$timestep, policy1$backlog_prop, type = "l",
ylim = c(0, 0.5))
plot(policy1$timestep, policy1$backlog_prop, type = "l",
ylim = c(0, 0.5), xlab = "Time", ylab = "Backlog proportion")
plot(policy1$timestep, policy1$backlog_prop, type = "l",
ylim = c(0, 0.5), xlab = "Time", ylab = "Backlog proportion",
col = "firebrickred")
policy1 <- det_model_action(initialState, 10, dtmc, action_5da)
tail(policy1, 5)
plot(policy1$timestep, policy1$backlog_prop, type = "l",
ylim = c(0, 0.5), xlab = "Time", ylab = "Backlog proportion",
col = "firebrick")
shiny::runApp('tpi/App-forecast')
shiny::runApp('tpi/App-forecast')
#  TITLE: FORECASTING APP FOR Educaiton Funding Agency
#  PURPOSE: forecasting using standard time series methods a range of
#  commonly used indices used by the EFA to assist in predicitng future costs and or
#  uncertainity about such costs.
#  TOOL: we use the dygraphs package based on the javascript dygraphs charts plotting.
#  http://rstudio.github.io/dygraphs/
#  We start off with a minimal viable product forecastign using ARIMA and or ETS for
#  the commonly used indices, with the aim of adding more later. We' put together the code to
#  plot here and then build it into a shiny app later.
#  DATE: 29/06/2016
#SETUP
rm(list = ls()) #  clear workspace
set.seed(1337)
#LIBRARY - check if packages are installed and load them
library(dplyr)
library(zoo)
library(forecast)
library(lubridate)
library(dygraphs)
library(ZRA)  #  handle forecast objects with dygraphs
#INPUTS
h <- 8  #  the forecast horizon, predicting h quarters into the future
confidence_levels <- c(80, 95)  #  default 80 and 95% confidence intervals, can change here
wd <- "C://Users//mammykins//Google Drive//R//tpi/App-forecast"  #  the working directory, the address of the relevant input file or raw data on your computer, note the // separation.
todays_yr_qtr <- as.yearqtr(as.Date(x = today(), format = "%Y-%m-%d"))  #  what is the date, year and quarter? This can be manually adjusted to reproduce early forecasts.
voi <- "cpi"  #  variable of interest, SHINY input name
######################
######################
# ----
#SETUP
setwd(wd)
#READ DATA
ukdata <- paste("master_data", ".csv", sep = "")  #  file should be located in wd
if ( all(list.files() != ukdata))  warning('You are in the wrong folder or the desired file does not exist in the current working folder!')
ukdata <- read.csv(ukdata,
header = TRUE)  # in tidy dataframe format, one row per observation
if ( any(is.na(tail(ukdata)) )) warning('There are some missing values in the data, check the csv.file for blank spaces or columns. Check the data is up-to-date, gaps are problematic, if found this tool should not be used.')
#SELECT DATA
ukdata_ts <- ts(data = ukdata[, voi], end = todays_yr_qtr, frequency = 4) %>%
na.omit()
#ZRA custom
#  changed startvalue <- end(data) + 1 due to quarterly data
zra_custom <- function(data, FP = 10, SL = c(0.8, 0.95), ...)
{
startvalue <- end(data) + 0.25
f <- frequency(data)
d <- data
if (is.ts(d) == TRUE) {
if (is.matrix(d) == TRUE) {
result <- NULL
stop("Only 1 Time Series can analyzed at once")
}
else {
prognose <- forecast(d, h = FP, level = SL, ...)
result <- list()
result$series <- data
result$SL <- SL
result$FP <- FP
if (length(SL) == 1) {
up1 <- ts(prognose$upper[, 1], start = startvalue,
frequency = f)
low1 <- ts(prognose$lower[, 1], start = startvalue,
frequency = f)
fit1 <- (up1 + low1)/2
result$up1 <- up1
result$low1 <- low1
result$fit1 <- fit1
result$piv1 <- cbind(fit1, up1, low1)
}
if (length(SL) == 2) {
up1 <- ts(prognose$upper[, 1], start = startvalue,
frequency = f)
low1 <- ts(prognose$lower[, 1], start = startvalue,
frequency = f)
fit1 <- (up1 + low1)/2
up2 <- ts(prognose$upper[, 2], start = startvalue,
frequency = f)
low2 <- ts(prognose$lower[, 2], start = startvalue,
frequency = f)
fit2 <- (up2 + low2)/2
result$up1 <- up1
result$low1 <- low1
result$fit1 <- fit1
result$piv1 <- cbind(fit1, up1, low1)
result$up2 <- up2
result$low2 <- low2
result$fit2 <- fit2
result$piv2 <- cbind(fit2, up2, low2)
}
if (length(SL) != 1 & length(SL) != 2) {
stop("Only 2 Significance levels can be plotted at once.")
}
}
}
else {
result <- NULL
stop("Data have to be a Time Series Obejct, with the Class ts.")
}
class(result) <- "ZRA"
return(result)
}
zra <- zra_custom(ukdata_ts, FP = h, SL = confidence_levels)
#  gap bug caused by startvalue <- end(data)[1] + 1, should be 0.25 for quarterly
plot(zra)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
ts(data = ukdata[, input$voi], end = todays_yr_qtr, frequency = 4) %>%
na.omit() %>%  #  make quarterly time series, forecast, create zra class
zra_custom(FP = input$h, SL = input$confidence_levels)
ts(data = ukdata[, "tpi"], end = todays_yr_qtr, frequency = 4) %>%
na.omit() %>%  #  make quarterly time series, forecast, create zra class
zra_custom(FP = 8, SL = c(0.8, .95))
runApp()
runApp()
zra_tpi <- ts(data = ukdata[, "tpi"], end = todays_yr_qtr, frequency = 4) %>%
na.omit() %>%  #  make quarterly time series, forecast, create zra class
zra_custom(FP = 8, SL = c(0.8, .95))
plot(zra_tpi)
zra_tpi$piv1
class(zra_tpi)
runApp()
runApp()
runApp()
runApp()
