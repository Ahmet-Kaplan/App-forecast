shiny::runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
shiny::runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
?renderDataTable
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
?datatable
?renderDataTable
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
?styleColorBar
?range()
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
?formatCurrency
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
range(condition_backlog_data$cost_backlog)
filter(condition_backlog_data, cost_backlog > 9000000
)
filter(school_locations, urn = 138681)
filter(school_locations, urn == 138681)
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
runApp('GitHub/App-condainment')
shiny::runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
?if_else()
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
?formatRound
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
?renderDataTable
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
?datable()
?datatable
runApp('GitHub/App-surplus_school')
runApp('GitHub/App-surplus_school')
install.packages("shiny")
install.packages("leaflet")
install.packages("RColorBrewer")
shiny::runApp('GitHub/App-surplus_school')
install.packages("shiny")
install.packages("leaflet")
shiny::runApp('GitHub/App-surplus_school')
install.packages("sparklyr")
library(sparklyr)
sc <- spark_connect(master = "local")
devtools::install_github("rstudio/sparklyr")
install.packages("digest")
install.packages("jsonlite")
devtools::install_github("rstudio/sparklyr")
library(sparklyr)
spark_install(version = "1.6.2")
sc <- spark_connect(master = "local")
library(dplyr)
library(blockbuster)
blockbuster_pds[51,]
filter(blockbuster_pds, siteid == 1301)
my_site <- filter(blockbuster_pds, siteid == 1301)
my_site_10_years_later <- blockbuster(mysite, 10)
my_site_10_years_later <- blockbuster(my_site, 10)
my_site_10_years_later[1]
my_site_10_years_later[2]
my_site_10_years_later[1]
str(my_site_10_years_later[1])
copy_to_sc_and_name <- function(sc, blockbuster_tibble, year_of_interest) {
copy_to(sc, blockbuster_tibble[year_of_interest])
}
year_0_tbl <- copy_to_sc_and_name(sc, my_site_10_years_later, 1)
year_5_tbl <- copy_to_sc_and_name(sc, my_site_10_years_later, 6)
year_10_tbl <- copy_to_sc_and_name(sc, my_site_10_years_later, 11)
src_tbls(sc)
year_0_tbl <- copy_to(sc, my_site_10_years_later[1])
my_site_10_years_later[1]
my_site_10_years_later[[1]]
year_0_tbl <- copy_to(sc, my_site_10_years_later[[1]])
class(iris)
class(my_site_10_years_later[1])
class(my_site_10_years_later[[1]])
year_0_tbl <- copy_to(sc, as.dataframe(my_site_10_years_later[[1]]))
year_0_tbl <- copy_to(sc, as.data.frame(my_site_10_years_later[[1]]))
iris_tbl <- copy_to(sc, iris)
flights_tbl <- copy_to(sc, nycflights13::flights, "flights")
batting_tbl <- copy_to(sc, Lahman::Batting, "batting")
src_tbls(sc)
install.packages(c("nycflights13", "Lahman"))
iris_tbl <- copy_to(sc, iris)
flights_tbl <- copy_to(sc, nycflights13::flights, "flights")
batting_tbl <- copy_to(sc, Lahman::Batting, "batting")
src_tbls(sc)
getwd()
setwd("D:/Google Drive/R/tpi")
---
title: "06_TPI_forecasting_BCIS_UK"
author: "Matthew Gregory"
date: "29 April 2016"
output:
word_document: default
html_document: default
notes: A knitr reproducible document
objective: Forecast TPI for the next eight quarters
modified: null
input: allin_tpi_uk.csv
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, message = FALSE, warning = FALSE, echo = FALSE}
rm(list = ls()) #  clear workspace
set.seed(1337)
#LIBRARY - check if packages are installed and load them
library(dplyr)
library(zoo)
library(forecast)
library(lubridate)
# ----
#######################
####################### You should only make changes here
####################### in the input section
#INPUTS
h <- 8  #  the forecast horizon, predicting h quarters into the future
confidence_levels <- c(80, 95)  #  default 80 and 95% confidence intervals, can change here
wd <- "C://Users//mammykins//Google Drive//R//tpi"  #  the working directory, the address of the relevant input file or raw data on your computer, note the // separation.
todays_yr_qtr <- as.yearqtr(as.Date(x = today(), format = "%Y-%m-%d"))  #  what is the date, year and quarter? This can be manually adjusted to reproduce early forecasts.
max_forecast <- todays_yr_qtr + h / 4  #  four quarters in a year
######################
######################
# ----
#SETUP
setwd(wd)
```
## Forecasting UK BCIS TPI for the next `r h` quarters
The purpose of this document is to forecast the next `r h` quarters of the United Kingdom (UK) Building Cost Information Service (BCIS) Tender Price Index (TPI) from `r todays_yr_qtr` to `r max_forecast`.
The [ARIMA(2, 1, 2) with drift model](https://www.otexts.org/fpp/8) is the preferred time series forecasting model for predicting UK TPI. This consensus was reached after a comprehensive review of time series models and  assessment of their forecasts using cross validation, with the [prediction accuracy quantified](https://www.otexts.org/fpp/2/5) using the mean absolute error (MAE). This conclusion is supported by the preceeding documentation of this series (01-05) as part of the TPI prediction project undertaken by the Condition Data and Cost team. The project was conducted by Matthew Gregory led by Adam Bray.
## Input
The raw data for this model is an Excel csv file. The data is sacrosanct and should not be manipulated or analysed in Excel, as this can interfere with the automation of the forecast. The raw data should be updated as appropriate when the BCIS TPI values are updated or become fixed.
```{r, message = FALSE, echo = FALSE}
#READ DATA
ukdata <- paste("allin_tpi_uk", ".csv", sep = "")  #  file should be located in wd
if ( all(list.files() != ukdata))  warning('You are in the wrong folder or the desired file does not exist in the current working folder!')
ukdata <- read.csv(ukdata,
header = TRUE)  # in tidy dataframe format, one row per observation
if ( any(is.na(ukdata)) ) warning('There are some missing values in the data, check the csv.file for blank spaces or columns.')
```
## Output
We run the model on the time series data and forecast the next `r h` quarters. We output a plot to aid in communicating the forecast and the prediction intervals facilitating assessment of the error in the forecast.
```{r, message = FALSE, echo = FALSE}
#GET RECENT TIME SERIES DATA for UK TPI
# This converts the raw data into a suitable time series object.
# We start by removing any zero tpi values and filtering those rows that are prior to the present data, that way we ensure we make forecasts from the present into the future
# We build a dataframe from this subset and convert it into a zoo object which is comptabible
ukdata_nozero <- filter(ukdata, tpi > 0 &
as.yearqtr(date, format = "%b-%y") < todays_yr_qtr)
df <- data.frame(thedate = as.yearqtr(ukdata_nozero$date, format = "%b-%y"),
tpi = ukdata_nozero$tpi,
stringsAsFactors = FALSE)
z <- zoo(x = df$tpi, order.by = df$thedate)  #  i prefer reading as zoo as it explicitly indexes the date, useful for spotting a gap in the dates or other errors
tpi_forecast <- forecast(Arima(z, order = c(2, 1, 2),
include.drift = TRUE, method = "ML"), h = h)
plot(tpi_forecast)
tpi_forecast
```
Exact values are provided in the table with forecast point estimates providing our best guess of future UK BCIS TPI values. Uncertainty around these estimates are provided by the the prediction intervals with the default of `r confidence_levels`% . In addition the data has been output in an Excel .csv file (with the filename: `r paste(sub(pattern = " ", replacement = "_", todays_yr_qtr), "_bcis_tpi_forecast.csv", ".csv", sep = "")`).
```{r, echo = FALSE}
# Write CSV in R, saved as
write.csv(tpi_forecast, file = paste(sub(pattern = " ", replacement = "_", todays_yr_qtr), "_bcis_tpi_forecast.csv", sep = ""))
```
### Comparison of ARIMA prediction with UK BCIS prediction
The UK BCIS do not publish their methods for how they forecast but it is expected to be a time series linear regression with manual "tweaking" by forecasters. It is relevant and interesting to compare the two forecasting methods. The validation of both methods can be achieved through recording predictions and comparing against reality. This quarterly-produced auto-document acts as a historical record.
We can plot the ARIMA forecast (blue) and prediction intervals (shading) against the UK BCIS forecast (red-dashed).
```{r echo=FALSE}
ukbcis <- filter(ukdata, as.yearqtr(date, format = "%b-%y") >= todays_yr_qtr,
as.yearqtr(date, format = "%b-%y") < todays_yr_qtr + h/4  # /4 Quarterly
)
df_bcis <- data.frame(thedate = as.yearqtr(ukbcis$date, format = "%b-%y"),
tpi = ukbcis$tpi,
stringsAsFactors = FALSE)
z_bcis <- zoo(x = df_bcis$tpi, order.by = df_bcis$thedate)
# Plot
plot(tpi_forecast, xlim = c(todays_yr_qtr - h/4, todays_yr_qtr + h/4))
lines(z_bcis, col = "red", lty = "dashed")
```
### Caveat
There may be extra noise in the most recent TPI values which have not been "fixed" (80 BQs or 18 months required for fixation), this adds an additional source of error or bias to any forecasts that use this data in their calculations.
Time series models perform well for predicting TPI except in periods of market shock, such as the 2008 economic downturn. Increased market volatility during these periods renders the forecast from this method imprecise. This model should not be used during such periods.
## References
* Hyndman, R. J., & Khandakar, Y. (2008). Automatic time series forecasting : the forecast package for R. Journal Of Statistical Software, 27(3), 1-22. http://doi.org/10.18637/jss.v027.i03
## Appendix
For the reader's convenience here we print both our ARIMA forecast and the UK BCIS forecast for the next `r h` Quarters.
```{r}
tpi_forecast$mean
z_bcis
```
setwd("D:/Google Drive/R/tpi")
setwd("~/GitHub/App-forecast")
shiny::runApp()
runApp()
