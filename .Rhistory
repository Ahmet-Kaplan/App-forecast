install.packages("gputools")
install.packages("C:/Users/mammykins/Downloads/rpux_0.5.2_win/rpux_0.5.2_win/rpud_0.5.2.zip", repos = NULL, type = "win.binary")
install.packages("C:/Users/mammykins/Downloads/rpux_0.5.2_win/rpux_0.5.2_win/rpudplus_0.5.2.zip", repos = NULL, type = "win.binary")
library(rpud)
getwd()
Sys.getenv("C:/Users/mammykins/Google Drive/R")
library(rpud)
#ACTIVATION
Sys.getenv("C:/Users/mammykins/Google Drive/R")
Sys.getenv("HOME")
?Sys.getenv()
install.packages("gputools")
0.05^9
0.05^5
0.5^5
0.5^4
0.5^7
0.5^8
0.5^9
1854*12
559.15/3
3*140
559.15/3
186.39/2
186*3
library(markovchain)
tmA <- matrix(c(0.7, 0.3, 0, 0,    #  a
0, 0.5, 0.5, 0.01,   #  b
0, 0, 0.4, 0.6,         #  c
0, 0, 0, 1),        #  d
nrow = 4, byrow = TRUE) #define the transition matrix
dtmcA <- new("markovchain", transitionMatrix = tmA,
states = c("a", "b", "c", "d"),
name = "element") #create the DTMC
dtmcA
tmA <- matrix(c(0.7, 0.3, 0, 0,    #  a
0, 0.5, 0.5, 0,   #  b
0, 0, 0.4, 0.6,         #  c
0, 0, 0, 1),        #  d
nrow = 4, byrow = TRUE) #define the transition matrix
dtmcA <- new("markovchain", transitionMatrix = tmA,
states = c("a", "b", "c", "d"),
name = "element") #create the DTMC
dtmcA
set.seed(1337)
#n <-   #
steps <- 1
########
initialState <- c(12, 35, 18, 5)   others
finalState <- initialState*dtmcA ^ steps #using power operator
finalState
set.seed(1337)
#n <-   #
steps <- 1
########
initialState <- c(12, 35, 18, 5)
finalState <- initialState*dtmcA ^ steps #using power operator
finalState
library(markovchain)
library(dplyr)
mydata <- read.csv("https://raw.githubusercontent.com/mammykins/piggyBac-data/master/master2015jan.csv",
header = TRUE)
names(mydata)
trans_efficiency <- mydata %>% select(g0.lambda) %>% na.omit() %>% median()
trans_efficiency <- mydata %>% select(g0.lambda) %>% na.omit()
median(trans_efficiency)
trans_efficiency
median(as.numeric(trans_efficiency))
class(trans_efficiency)
trans_efficiency <- mydata %>% select(g0.lambda)
median(as.numeric(trans_efficiency, na.rm = TRUE))
class(trans_efficiency)
trans_efficiency
median(trans_efficiency, na.rm = TRUE)
trans_efficiency <- mydata %>% select(g0.lambda) %>% median(na.rm = TRUE)
trans_efficiency$g0.lambda
trans_efficiency <- mydata %>% select(g0.lambda) %>% median(g0.lambda, na.rm = TRUE)
mydata <- read.csv("https://raw.githubusercontent.com/mammykins/piggyBac-data/master/master2015jan.csv",
header = TRUE) %>% select(g0.lambda, surv)
trans_efficiency <- median(mydata$g0.lambda, na.rm = TRUE)
s <-  median(mydata$surv, na.rm = TRUE) %>% round(digits = 5)
trans_efficiency <- median(mydata$g0.lambda, na.rm = TRUE) %>% round(digits = 5)
library(markovchain)
##  Get the diamond back moth summary statistics of interest
library(dplyr)
mydata <- read.csv("https://raw.githubusercontent.com/mammykins/piggyBac-data/master/master2015jan.csv",
header = TRUE) %>% select(g0.lambda, surv)
s <-  median(mydata$surv, na.rm = TRUE) %>% round(digits = 5)
trans_efficiency <- median(mydata$g0.lambda, na.rm = TRUE) %>% round(digits = 5)
tmA <- matrix(c(0, s, 1 - s, 0,     #  egg to...
0, 0, 1 - trans_efficiency, trans_efficiency,   #  g0 to...
0, 0, 1, 0,         #  dead to...
0, 0, 0, 1),
nrow = 4, byrow = TRUE) #define the transition matrix
dtmcA <- new("markovchain", transitionMatrix = tmA,
states = c("egg", "g0", "dead", "transgenic"),
name = "diamondback") #create the DTMC
dtmcA
plot(dtmcA, main = "Transition probability matrix for DBM")
library(diagram)
plot(dtmcA, main = "Transition probability matrix for DBM", package = "diagram", box.size = 0.04)
vignette("diagram")
plotmat(dtmcA, main = "Transition probability matrix for DBM", box.size = 0.04)
plotmat(dtmcA, main = "Transition probability matrix for DBM", package = "diagram", box.size = 0.04, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.size = 0.1, box.type = "square", box.prop = 0.5)
plotmat(dtmcA, main = "Transition probability matrix for DBM", package = "diagram",
lwd = 1, box.lwd = 2, cex.txt = 0.8,
box.size = 0.1, box.type = "square",
box.prop = 0.5)
plot(dtmcA, main = "Transition probability matrix for DBM", package = "diagram",
lwd = 1, box.lwd = 2, cex.txt = 0.8,
box.size = 0.1, box.type = "square",
box.prop = 0.5)
dtmcA
plot(dtmcA, main = "Transition probability matrix for DBM", package = "diagram",
lwd = 1, box.lwd = 2, cex.txt = 0.8,
box.size = 0.1, box.type = "square",
box.prop = 0.5,
names = c("Egg", "Injection survivor", "Dead or not transgenic", "Transgenic"))
plot(dtmcA, main = "Transition probability matrix for DBM", package = "diagram",
lwd = 1, box.lwd = 2, cex.txt = 0.8,
box.size = 0.1, box.type = "square",
box.prop = 0.5, digits = 2)
plot(dtmcA, main = "Transition probability matrix for DBM", package = "diagram",
lwd = 1, box.lwd = 2, cex.txt = 0.8,
box.size = 0.1, box.type = "square",
box.prop = 0.5, digits = 5)
tmA <- matrix(c(0.7, 0.3, 0, 0,    #  a
0, 0.5, 0.5, 0,   #  b
0, 0, 0.4, 0.6,         #  c
0, 0, 0, 1),        #  d
nrow = 4, byrow = TRUE) #define the transition matrix
dtmcA <- new("markovchain", transitionMatrix = tmA,
states = c("a", "b", "c", "d"),
name = "element") #create the DTMC
dtmcA
set.seed(1337)
#n <-   #
steps <- 1
########
initialState <- c(12, 35, 18, 5)
finalState <- initialState*dtmcA ^ steps #using power operator
finalState
steps <- 1:5
set.seed(1337)
#n <-   #
steps <- 1:10
########
initialState <- c(12, 35, 18, 5)
finalState <- initialState*dtmcA ^ steps #using power operator
finalState
steps <- 1:10
steps
rmarkovchain(n = 10, object = mcWeather, t0 = initialState)
tmC <- matrix(c(0.7, 0.3, 0, 0,    #  a
0, 0.5, 0.5, 0,   #  b
0, 0, 0.4, 0.6,         #  c
0, 0, 0, 1),        #  d
nrow = 4, byrow = TRUE) #define the transition matrix
dtmcC <- new("markovchain", transitionMatrix = tmC,
states = c("a", "b", "c", "d"),
name = "element") #create the DTMC
dtmcC
set.seed(1337)
#n <-   #
steps <- 1
########
initialState <- c(12, 35, 18, 5)
finalState <- initialState*dtmcC ^ steps #using power operator
finalState
set.seed(1337)
initialState <- c(12, 35, 18, 5)
########
rmarkovchain(n = 10, object = dtmcC, t0 = initialState)
?rmarkovchain()
show(dtmcC)
timesteps <- 10
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmcC ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
pipe_df
glimpse(pipe_df)
pipe_df
tmC <- matrix(c(0.9, 0.1, 0, 0,    #  a
0, 0.8, 0.2, 0,   #  b
0, 0, 0.6, 0.4,         #  c
0, 0, 0, 1),        #  d
nrow = 4, byrow = TRUE) #define the transition matrix
dtmcC <- new("markovchain", transitionMatrix = tmC,
states = c("a", "b", "c", "d"),
name = "element") #create the DTMC
dtmcC
set.seed(1337)
show(dtmcC)
#n <-   #
steps <- 1
########
initialState <- c(12, 35, 18, 5)
finalState <- initialState*dtmcC ^ steps #using power operator
finalState
#INPUT
set.seed(1337)
initialState <- c(12, 35, 18, 5)
timesteps <- 10
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmcC ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#OUTPUT
pipe_df
set.seed(1337)
initialState <- c(12, 35, 18, 5)
timesteps <- 20
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmcC ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#OUTPUT
pipe_df
set.seed(1337)
initialState <- c(12, 35, 18, 5)
timesteps <- 50
#SIMULATION
pipe_df <- data.frame( "timestep" = numeric(),
"a" = numeric(), "b" = numeric(),
"c" = numeric(), "d" = numeric(),
stringsAsFactors = FALSE)
for (i in 0:timesteps) {
newrow <- as.list(c(i, round(as.numeric(initialState * dtmcC ^ i), 0)))
pipe_df[nrow(pipe_df) + 1, ] <- newrow
}
#OUTPUT
head(pipe_df, 10)
tail(pipe_df, 5)
(pipe_df[row,]$timestep)+1
(pipe_df[row,]$timestep)
ab.state  occurs.at (pipe_df[row,]$timestep)
plot(pipe_df$timestep, pipe_df$a)
points(pipe_df$timestep,pipe_df$b, col="red")
points(pipe_df$timestep,pipe_df$c, col="green")
points(pipe_df$timestep,pipe_df$d, col="blue")
pipe_df
plot(pipe_df$timestep, pipe_df$b)
points(pipe_df$timestep,pipe_df$a, col="red")
points(pipe_df$timestep,pipe_df$c, col="green")
points(pipe_df$timestep,pipe_df$d, col="blue")
plot(pipe_df$timestep, pipe_df$b, ylim = c(0, 70))
points(pipe_df$timestep,pipe_df$a, col="red")
points(pipe_df$timestep,pipe_df$c, col="green")
points(pipe_df$timestep,pipe_df$d, col="blue")
ab.state  occurs.at  (pipe_df[row,]$timestep)+1
library(RColorBrewer)
colours <- brewer.pal(4, "Set1")
plot(pipe_df$timestep, pipe_df$b, ylim = c(0, 70), col = colours[1])
points(pipe_df$timestep,pipe_df$a, col = colours[2])
points(pipe_df$timestep,pipe_df$c, col = colours[3])
points(pipe_df$timestep,pipe_df$d, col = colours[4])
colours <- brewer.pal(4, "Set1")
plot(pipe_df$timestep, pipe_df$b, ylim = c(0, 70), col = colours[1], type = "l")
lines(pipe_df$timestep,pipe_df$a, col = colours[2])
lines(pipe_df$timestep,pipe_df$c, col = colours[3])
lines(pipe_df$timestep,pipe_df$d, col = colours[4])
legend(x = c("a", "b", "c", "d"), col = colours)
?legend()
legend(legend = c("a", "b", "c", "d"), col = colours)
legend("right", legend = c("a", "b", "c", "d"), col = colours)
legend("right", legend = c("a", "b", "c", "d"), fill = colours)
plot(pipe_df$timestep, pipe_df$b, ylim = c(0, 70), col = colours[1], type = "l",
xlab = "Horizon in years", ylab = "Frequency of pipes in state")
lines(pipe_df$timestep,pipe_df$a, col = colours[2])
lines(pipe_df$timestep,pipe_df$c, col = colours[3])
lines(pipe_df$timestep,pipe_df$d, col = colours[4])
legend("right", legend = c("a", "b", "c", "d"), fill = colours)
tail(pipe_df)
absorbingStates(dtmcC)
absorbingStates(dtmcC)
transientStates(dtmcC)
steadyStates(dtmcC)
sum(initialState)
filter(pipe_df, "a" == 0, "b" == 0, "c"  == 0)
filter(pipe_df, "c"  == 0)
filter(pipe_df, c  == 0)
filter(pipe_df, a == 0, b == 0, c  == 0)
head(filter(pipe_df, a == 0, b == 0, c  == 0), n = 1)
head(filter(pipe_df, a == 0, b == 0, c  == 0, d == sum(initialState)), n = 1)
install.packages("shiny")
install.packages("rsconnect")
install.packages("rsconnect")
install.packages("rsconnect")
shiny::runApp('tpi/App-forecast')
runApp('cdc/App-det')
runApp('cdc/App-det')
runApp('cdc/App-det')
stop()
(253256/454420)*6979468
(253226/454420)*6979468
(253226/(253226+169637+29153+2405
))*6979468
pdsp_data
filter(pdsp_data, Building_Type == built_pre_1919)
filter(pdsp_data, Building_Type == "built_pre_1919")
?round()
shiny::runApp('tpi/App-forecast')
runApp('tpi/App-forecast')
runApp('tpi/App-forecast')
runApp('tpi/App-forecast')
?ZRA()
runApp('tpi/App-forecast')
runApp('tpi/App-forecast')
runApp('tpi/App-forecast')
runApp('tpi/App-forecast')
?print()
set.seed(1337)
#LIBRARY - check if packages are installed and load them
library(dplyr)
library(zoo)
library(forecast)
library(lubridate)
library(dygraphs)
library(ZRA)
#READ DATA
ukdata <- paste("master_data", ".csv", sep = "")  #  file should be located in wd
if ( all(list.files() != ukdata))  warning('You are in the wrong folder or the desired file does not exist in the current working folder!')
ukdata <- read.csv(ukdata,
header = TRUE)  # in tidy dataframe format, one row per observation
#TODAY's DATE
todays_yr_qtr <- as.yearqtr(as.Date(x = today(), format = "%Y-%m-%d"))
getwd()
setwd("C:/Users/mammykins/Google Drive/R/tpi/App-forecast")
set.seed(1337)
#LIBRARY - check if packages are installed and load them
library(dplyr)
library(zoo)
library(forecast)
library(lubridate)
library(dygraphs)
library(ZRA)
#READ DATA
ukdata <- paste("master_data", ".csv", sep = "")  #  file should be located in wd
if ( all(list.files() != ukdata))  warning('You are in the wrong folder or the desired file does not exist in the current working folder!')
ukdata <- read.csv(ukdata,
header = TRUE)  # in tidy dataframe format, one row per observation
#TODAY's DATE
todays_yr_qtr <- as.yearqtr(as.Date(x = today(), format = "%Y-%m-%d"))
max_forecast <- todays_yr_qtr + input$h / 4  #  four quarters in a year
max_forecast <- todays_yr_qtr + 8 / 4  #  four quarters in a year
df <- data.frame(thedate = as.yearqtr(ukdata$date, format = "%b-%y"),
variable_of_interest = ukdata[, "tpi"],
stringsAsFactors = FALSE) %>%
filter(thedate < todays_yr_qtr) %>%
na.omit()
z <- zoo(x = df$variable_of_interest, order.by = df$thedate)  #  i prefer reading as zoo as it explicitly indexes the date, useful for spotting a gap in the dates or other errors
ukdata_ts <- as.ts(z)
#PLOT
zra <- ZRA(ukdata_ts, FP = input$h, SL = input$confidence_levels)
z <- zoo(x = df$variable_of_interest, order.by = df$thedate)  #  i prefer reading as zoo as it explicitly indexes the date, useful for spotting a gap in the dates or other errors
ukdata_ts <- as.ts(z)
#PLOT
zra <- ZRA(ukdata_ts, FP = 8, SL = input$confidence_levels)
z <- zoo(x = df$variable_of_interest, order.by = df$thedate)  #  i prefer reading as zoo as it explicitly indexes the date, useful for spotting a gap in the dates or other errors
ukdata_ts <- as.ts(z)
#PLOT
zra <- ZRA(ukdata_ts, FP = 8, SL = c(0.8, 0.95))
str(zra)
runApp()
runApp()
runApp()
zra@fit1
zra$fit1
str(zra)
tail(zra$series, 1)
tail(ukdata_ts, 1)
tail[174]
tail[174,]
ukdata_ts[174]
ukdata_ts[[174]]
str(ukdata_ts)
names(ukdata_ts)
str(z)
z@Index
z$Index
z
tail(z, 1)
todays_yr_qtr != tail(z, 1)
todays_yr_qtr != z[length(z)]
inflation <- function(base_year_value, forecasted_point_estimates) {
inflation_percentage <- round(x = ((base_year_value - forecasted_point_estimates) / base_year_value) * 100,
digits = 2)
}
inflation(tail(ukdata_ts, 1), c(200, 300, 256))
inflation <- function(base_year_value, forecasted_point_estimates) {
inflation_percentage <- round(x = ((base_year_value - forecasted_point_estimates) / base_year_value) * 100,
digits = 2)
return(inflation_percentage)
}
inflation(tail(ukdata_ts, 1), c(200, 300, 256))
tail(ukdata_ts, 1)
#INFLATION
inflation <- function(base_year_value, forecasted_point_estimates) {
inflation_percentage <- round(x = ((forecasted_point_estimates - base_year_value) / base_year_value) * 100,
digits = 2)
return(inflation_percentage)
}
inflation(tail(ukdata_ts, 1), c(200, 300, 256))
?list()
inflation(tail(ukdata_ts, 1), zra$fit1)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?a()
runApp()
